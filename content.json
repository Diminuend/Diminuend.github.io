{"posts":[{"title":"VSCode 自动生成注释 Doxygen Documentation Generator","text":"插件： 配置规则如下：· 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 // The prefix that is used for each comment line except for first and last. &quot;doxdocgen.c.commentPrefix&quot;: &quot; * &quot;, // Smart text snippet for factory methods/functions. &quot;doxdocgen.c.factoryMethodText&quot;: &quot;Create a {name} object&quot;, // Smart text snippet for getters. &quot;doxdocgen.c.getterText&quot;: &quot;Get the {name} object&quot;, // The last line of the comment that gets generated. If empty it won't get generated at all. &quot;doxdocgen.c.lastLine&quot;: &quot; */&quot;, // Smart text snippet for setters. &quot;doxdocgen.c.setterText&quot;: &quot;Set the {name} object&quot;, // Doxygen comment trigger. This character sequence triggers generation of Doxygen comments. &quot;doxdocgen.c.triggerSequence&quot;: &quot;/**&quot;, // Smart text snippet for constructors. &quot;doxdocgen.cpp.ctorText&quot;: &quot;Construct a new {name} object&quot;, // Smart text snippet for destructors. &quot;doxdocgen.cpp.dtorText&quot;: &quot;Destroy the {name} object&quot;, // The template of the template parameter Doxygen line(s) that are generated. If empty it won't get generated at all. &quot;doxdocgen.cpp.tparamTemplate&quot;: &quot;@tparam {param} &quot;, // The template for the file parameter in Doxygen. &quot;doxdocgen.file.fileTemplate&quot;: &quot;@file {name}&quot;, // Version number for the file. &quot;doxdocgen.file.versionTag&quot;: &quot;@version 1.0&quot;, // File copyright documentation tag. Array of strings will be converted to one line per element. Can template {year}. &quot;doxdocgen.file.copyrightTag&quot;: [ &quot;@copyright Copyright (c) Greenway&quot; ], // Additional file documentation. One tag per line will be added. Can template `{year}`, `{date}`, `{author}`, `{email}` and `{file}`. You have to specify the prefix. &quot;doxdocgen.file.customTag&quot;: [], // The order to use for the file comment. Values can be used multiple times. Valid values are shown in default setting. &quot;doxdocgen.file.fileOrder&quot;: [ &quot;file&quot;, &quot;brief&quot;, &quot;author&quot;, &quot;version&quot;, &quot;date&quot;, &quot;empty&quot;, &quot;copyright&quot;, &quot;empty&quot;, &quot;custom&quot; ], &quot;doxdocgen.generic.authorEmail&quot;: &quot;&quot;, // Set the name of the author. Replaces {author}. &quot;doxdocgen.generic.authorName&quot;: &quot;wenfeng.zeng&quot;, // If this is enabled a bool return value will be split into true and false return param. &quot;doxdocgen.generic.boolReturnsTrueFalse&quot;: true, // The template of the brief Doxygen line that is generated. If empty it won't get generated at all. &quot;doxdocgen.generic.briefTemplate&quot;: &quot;@brief 概述说明&quot;, // The format to use for the date. &quot;doxdocgen.generic.dateFormat&quot;: &quot;YYYY-MM-DD&quot;, // The template for the date parameter in Doxygen. &quot;doxdocgen.generic.dateTemplate&quot;: &quot;@date {date}&quot;, // Decide if you want to get smart text for certain commands. &quot;doxdocgen.generic.generateSmartText&quot;: true, // Whether include type information at return. &quot;doxdocgen.generic.includeTypeAtReturn&quot;: true, // How many lines the plugin should look for to find the end of the declaration. Please be aware that setting this value too low could improve the speed of comment generation by a very slim margin but the plugin also may not correctly detect all declarations or definitions anymore. &quot;doxdocgen.generic.linesToGet&quot;: 20, // The order to use for the comment generation. Values can be used multiple times. Valid values are shown in default setting. &quot;doxdocgen.generic.order&quot;: [ &quot;brief&quot;, &quot;param&quot;, &quot;return&quot;, &quot;custom&quot;, &quot;author&quot;, &quot;date&quot;, ], // Custom tags to be added to the generic order. One tag per line will be added. Can template `{year}`, `{date}`, `{author}`, `{email}` and `{file}`. You have to specify the prefix. &quot;doxdocgen.generic.customTags&quot;: [], // The template of the param Doxygen line(s) that are generated. If empty it won't get generated at all. &quot;doxdocgen.generic.paramTemplate&quot;: &quot;@param [in]{indent:8} {param} {indent:8} 输入参数描述&quot;, // The template of the return Doxygen line that is generated. If empty it won't get generated at all. &quot;doxdocgen.generic.returnTemplate&quot;: &quot;@return {type} 返回值描述&quot;, // Decide if the values put into {name} should be split according to their casing. &quot;doxdocgen.generic.splitCasingSmartText&quot;: true, // Array of keywords that should be removed from the input prior to parsing. &quot;doxdocgen.generic.filteredKeywords&quot;: [], // Substitute {author} with git config --get user.name. &quot;doxdocgen.generic.useGitUserName&quot;: false, // Substitute {email} with git config --get user.email. &quot;doxdocgen.generic.useGitUserEmail&quot;: false, &quot;doxdocgen.generic.authorTag&quot;: &quot;@author {author}&quot;, Backlinks","link":"/p/107b3c174e1d4974ac796d377119aa01/"},{"title":"VSCode Cortex Debug","text":"需要安装”Cortex-Debug”插件使用 1234567891011121314151617181920cwd:项目路径configFiles:要加载的OpenOCD配置文件device:目标设备标识符接口:用于连接的调试接口类型(默认为SWD) -用于J-Link和BMP探针。name:配置名称;显示在启动配置下拉菜单中。preLaunchTask:在调试会话开始之前运行的任务。指定在tasks.json中定义的任务。request:配置请求类型。可以是“发射”或“附加”。runToEntryPoint:如果启用，调试器将运行，直到主函数开始。serialNumber: J-Link专用参数。J-Link序列号-仅当多个J-Link连接到计算机时需要servertype: GDB服务器类型—支持jlink、openocd、pyocd、pe、stutilsvdFile:描述微控制器外设的SVD文件的路径;如果没有提供，那么可以根据输入的“设备”选择一个。这可能会根据“设备”自动加载。swoConfig: SWO/ITM配置。enabled:开启SWO解码。cpuFrequency: CPU的目标频率，单位为Hz。swoffrequency: SWO频率，单位为Hz。source:SWO数据来源。可以是“探针”直接从调试探针获得，也可以是串行端口设备使用调试探针外部的串行端口。decoders:SWO解码器配置label:输出窗口的标签。port: ITM端口号 “launch.json”配置文件内容 123456789101112131415161718192021222324252627{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Cortex Debug&quot;, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;executable&quot;: &quot;${config:user.executable}&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;type&quot;: &quot;cortex-debug&quot;, &quot;runToEntryPoint&quot;: &quot;main&quot;, &quot;servertype&quot;: &quot;jlink&quot;, &quot;interface&quot;: &quot;swd&quot;, &quot;liveWatch&quot;: { &quot;enabled&quot;: true, &quot;samplesPerSecond&quot;: 10 }, &quot;configFiles&quot;: [ &quot;interface/cmsis-dap.cfg&quot;, &quot;target/fm4.cfg&quot; ], &quot;device&quot;: &quot;${config:user.device}&quot; &quot;svdFile&quot;: &quot;${workspaceFolder}\\\\public\\\\platform\\\\chip\\\\gd32f30x\\\\SVD\\\\GD32F30x_HD.svd&quot; }, ]} 以下更新后可执行版本 123456789101112131415161718192021222324252627{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Cortex Debug&quot;, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;executable&quot;: &quot;${workspaceFolder}/output/app/GW_CN085_MB_GD32F303VC_APP.elf&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;type&quot;: &quot;cortex-debug&quot;, &quot;runToEntryPoint&quot;: &quot;main&quot;, &quot;servertype&quot;: &quot;jlink&quot;, &quot;interface&quot;: &quot;swd&quot;, &quot;liveWatch&quot;: { &quot;enabled&quot;: true, &quot;samplesPerSecond&quot;: 10 }, &quot;configFiles&quot;: [ &quot;interface/cmsis-dap.cfg&quot;, &quot;target/fm4.cfg&quot; ], &quot;device&quot;: &quot;GD32F303VC&quot; &quot;svdFile&quot;: &quot;${workspaceFolder}\\\\public\\\\platform\\\\chip\\\\gd32f30x\\\\SVD\\\\GD32F30x_HD.svd&quot; }, ]} .vscode/settings.json 文件内添加以下内容 123&quot;cortex-debug.JLinkGDBServerPath&quot;: &quot;C:\\\\Program Files (x86)\\\\SEGGER\\\\JLink\\\\JLinkGDBServerCL.exe&quot;,&quot;cortex-debug.armToolchainPath&quot;: &quot;C:\\\\Program Files\\\\GNU Arm Embedded Toolchain\\\\10 2021.10\\\\bin&quot;,&quot;cortex-debug.liveWatchRefreshRate&quot;: 1000, .vscode/tasks.json文件内添加以下内容 123456789101112131415161718{ &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;build&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: [ &quot;make -j16 dl&quot;// 替换为你的编译命令，在debug前进行编译下载 ], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true }, &quot;problemMatcher&quot;: [] } ] } Backlinks","link":"/p/459ea392bc8d45d2849ad16d238600ee/"},{"title":"Python打包exe","text":"按照打包工具pip install pyinstaller打包命令pyinstaller -F .\\Extract_images.py","link":"/p/4c27a52fa6074968a591f169ad413f28/"},{"title":"Specifying SVD Files - Marus&#x2F;cortex-debug GitHub Wiki","text":"Content mirrored for search engine indexing from: https://github.com/Marus/cortex-debug/wiki/Specifying-SVD-Files Why does this service exist? 📅 Last Modified: Thu, 21 Apr 2022 21:28:37 GMT Specifying SVD Files - Marus/cortex-debug GitHub WikiThe Cortex-Debug Extension uses System View Description (SVD) files to display information about the selected part, including the Cortex Peripherals view. There are two options for specifying an SVD file: Obtain the SVD file from your device manufacturer. For instance, with ST, using instructions at this link. Then in your launch.json, specify the location of the file using something like &quot;svdFile&quot;: &quot;./STM32F103.svd&quot;. Other vendors may ship SVD files when you install their SW or device pack. Find and install the appropriate Cortex Debug Device Support Pack by searching “Cortex Debug Device Support Pack” in the Visual Studio Marketplace. Then in your launch.json, specify the device using &quot;device&quot;: &quot;STM32F103xx&quot; or similar. When using an external gdb server in your launch configuration, the device setting is not really used for anything else. Therefore getting the svd file direct from the MCU vendor and using svdFile to specify is recommended. Background: https://github.com/Marus/cortex-debug/issues/288 🗂️ Page Index for this GitHub Wiki","link":"/p/649142f2b0474564855a0e6d9f562ce1/"},{"title":"电感相关知识","text":"交流电也可以通过线圈，但是线圈的电感对交流电有阻碍作用，这个阻碍叫做感抗。交流电越难以通过线圈，说明电感量越大，电感的阻碍作用就越大；交流电的频率高，也难以通过线圈，电感的阻碍作用也大。实验证明，感抗和电感成正比，和频率也成正比。如果感抗用XL表示，电感用L表示，频率用f表示，那么其计算公式为： XL=2πfL=ωLX_L = 2 \\pi f L = \\omega LXL​=2πfL=ωL 感抗的单位是欧。知道了交流电的频率f(Hz)和线圈的电感L(H)，就可以用上式把感抗计算出来。电感的单位是“亨利（H）”我们可利用电流与线圈的这种特殊性质来制成不同大小数值的电感器件，以组成不同功能的电路系统网络.公式详解 各种公式电感电压公式（L-V公式）u=−L∗di/dtu=-L*di/dtu=−L∗di/dt 其中V为电感中的电压，L为电感线圈的电感，di/dt为电流变化率。 感抗公式详解XL=2πfL=ωLX_L = 2 \\pi f L = \\omega LXL​=2πfL=ωL 符号 描述 单位 XLX_LXL​ 感抗 欧姆 ω\\omegaω 交流发电机运转的角速度 弧度/秒 fff 频率 赫兹 LLL 线圈电感 亨利 公式理解BUAK计算实例开关管导通 开关管关闭 电感的电流波形根据BUCK电路的运行原理，可以得出电感的电流公式。开关管导通： dIL=VL(ON)/L∗dtdI_L = V_L(ON) / L * dtdIL​=VL​(ON)/L∗dt 开关管关闭 dIL=VL(OFF)/L∗dtdI_L = V_L(OFF) / L * dtdIL​=VL​(OFF)/L∗dt 电感电流变化示意图如下，IOUT是平均电流；当开关管导通时，① VL(ON)=−(VIN−VSW−VOUT)(1) \\tag 1 V_L(ON) = -(V_{IN}-V_{SW}-V_{OUT}) VL​(ON)=−(VIN​−VSW​−VOUT​)(1) 其中： VL(ON)V_L(ON)VL​(ON)是开关管导通时电感两端电压； VINV_{IN}VIN​是输入电压； VSWV_{SW}VSW​是开关管Q1导通时的压降； VOUTV_{OUT}VOUT​是输出电压； 电感自感应电压② VL=−L∗dILdt(2) \\tag 2 V_L= -L * \\frac{dI_L}{dt} VL​=−L∗dtdIL​​(2) 假设ILPI_{LP}ILP​为开关管Q1关断之前瞬间的电流，ILTI_{LT}ILT​为开关管Q1导通之前瞬间的电流。 则结合公式①和②推出③ ILP−ILT=−VSW−VIN+VOUT∗TONL(3) \\tag 3 I_{LP}-I_{LT} = -\\frac{V_{SW}-V_{IN}+V_{OUT}*T_{ON}}{L} ILP​−ILT​=−LVSW​−VIN​+VOUT​∗TON​​(3) 同理，可推出Q1管关闭时：④ VL(OFF)=VD+VOUT(4) \\tag 4 V_L(OFF) = V_D + V_{OUT} VL​(OFF)=VD​+VOUT​(4) ⑤ ILP−ILT=(VD+VOUT∗TOFF)L(5) \\tag 5 I_{LP} - I_{LT} = \\frac{(V_D+V_{OUT}*T_{OFF})}{L} ILP​−ILT​=L(VD​+VOUT​∗TOFF​)​(5) 其中： VL(OFF)V_L(OFF)VL​(OFF)是开关管关闭时电感两端电压； VDV_DVD​是续流二极管Q2的压降； 根据伏秒定律，有⑥ ILP+ILT=2IOUT(6) \\tag 6 I_{LP}+I_{LT}=2I_{OUT} ILP​+ILT​=2IOUT​(6) 结合③和⑥得出开关管导通时的ILPI_{LP}ILP​，⑦ ILP=IOUT+(VIN−VSW−TOUT)∗TON2L(7) \\tag 7 I_{LP}=I_{OUT}+\\frac{(V_{IN}-V_{SW}-T_{OUT})*T_{ON}}{2L} ILP​=IOUT​+2L(VIN​−VSW​−TOUT​)∗TON​​(7) 结合⑤和⑥得出开关管关闭时的ILPI_{LP}ILP​，⑧ ILP=IOUT+(VD+VOUT∗TOFF)2L(8) \\tag 8 I_{LP} = I_{OUT} + \\frac{(V_D+V_{OUT}*T_{OFF})}{2L} ILP​=IOUT​+2L(VD​+VOUT​∗TOFF​)​(8) 占空比的计算占空比指开关管导通时间占开关管振荡周期的比率，可用公式⑨表示","link":"/p/6eedda635ed14b49b8735710c2ed3327/"},{"title":"VSCODE开发环境安装说明","text":"VS CODE开发环境安装说明 一、下载好软件安装包1.GCC—-编译和调试2.J-LINK—配合J-LINK仿真器支持调试和下载3. MSYS—Linux命令行支持，这里主要使用make4.VS CODE—IDE 二、安装软件包1.GCC（gcc-arm-none-eabi-10.3-2021.10-win32）—-直接安装2.J-LINK（V7.82c）3. MSYS—直接解压4.VS CODE—直接安装 三、环境变量设置这里演示的是默认安装路径，需要根据自己的安装路径进行修改，需要添加msys、Jlink、gcc的安装路径，如下图； 四、VSCODE插件安装需要安装cortex-debug插件以支持调试，直接在vscode插件搜索安装，安装完之后需要设置jlink和gcc安装路径，如下图； 以下可复制 12 &quot;cortex-debug.JLinkGDBServerPath&quot;: &quot;C:\\\\Program Files (x86)\\\\SEGGER\\\\JLink\\\\JLinkGDBServerCL.exe&quot;, &quot;cortex-debug.armToolchainPath&quot;: &quot;C:\\\\Program Files (x86)\\\\GNU Arm Embedded Toolchain\\\\10 2021.10\\\\bin&quot;, VSCode Cortex DebugVSCode 自动生成注释 Doxygen Documentation Generator Specifying SVD Files - Marus/cortex-debug GitHub Wiki","link":"/p/a170a61759d34e2283c05f05a9430426/"},{"title":"电池包通讯与编址","text":"1.1 输入端口-接上一个电池包 PIN号 PIN名 PIN方向 说明 1 EN 输入 唤醒电池包 2 ID_IN 输入 3 4 485-A 5 485-B 6 GNDD 接地 1.2 输出端口-接下一个电池包 PIN号 PIN名 PIN方向 说明 1 EN 输入 唤醒电池包 2 ID_OPUT 输入 3 4 485-A 5 485-B 6 IN-CHK 输入 端口拉低，MCU脚被拉高说明后面有接入 1.3 接口对插说明 PIN号 上一个包PIN 下一个包PIN 说明 1 EN EN 唤醒电池包，通常是主机的唤醒边缘或者按钮 2 ID_OUT ID_IN 使用上个BMS的IO来控制下个的电池包是否编址 3 4 485-A RS485-A-2 5 485-B RS485-B-2 6 IN-CHK GNDD 端口拉低，MCU脚被拉高说明后面有接入 2 基本描述 开机默认为加电包 收到主板消息后确认自己为主包 开始发起编址通讯 2.1需要内存 name 是否flash 说明 Main battery pack built in Y 存储是否电池包内置 \\ 0:外置电池包 \\ 1:内置电池包 BMS_MASTER N 表示是否为主包 BMS_END N 表示自己是否为末包 BMS_EDIT_ADDR N 2.2 并包协议2.2.1协议格式描述指定发送数据 描述 设备地址 功能码 命令码 长度 数据 CRC 主机发送 1byte 1byte 1byte 1byte N byte 2byte ^^ ADDR 0x10 CMD命令码 数据长度(0~255) …… 2byte 描述 设备地址 功能码 命令码 长度 CRC 从机回复 1byte 1byte 1byte 1byte ^^ ADDR 0x10 CMD命令码 数据长度(0~255) 读取数据 描述 设备地址 功能码 命令码 长度 CRC 主机发送 1byte 1byte 1byte 1byte ^^ ADDR 0x03 CMD命令码 数据长度(0~255) 描述 设备地址 功能码 命令码 长度 数据 CRC 从机回复 1byte 1byte 1byte 1byte N byte 2byte ^^ ADDR 0x03 CMD命令码 数据长度(0~255) …… 2byte 广播发送数据(仅适用广播MOS控制命令) 描述 设备地址 功能码 命令码 长度 BMS0:1 BMS2:3 … BMSn-1:n CRC 主机发送 1byte 1byte 1byte 1byte 1byte 1byte … 1byte ^^ 0x00 0x10 0x90 长度 … … … … 长度 为BMS个数的/2 BMS0:1 表示为第0个BMS与第一个从机的控制命令 其中数据低4位表示为BMS0,高4位表示为BMS1BMS0:为本机BMS1:第一个从机…BMSN:第N个从机 CMD命令码 命令码 读写 描述 0x50 R BMS主信息 0x51 R 版本信息 0x52 R 扩展数据 0x53 R 单体电压 0x54 R 单体温度 0x90 W MOS控制 0x91 W 编址命令,存在特殊回复 MOS控制命令MOS控制命令可以广播也可以单独控制 控制目标 断开(00b) 闭合(01b) 自动(10b) 保持(11b) 充电[3:2] 充电mos断开 充电mos闭合 充电MOS自动[^3] 充电MOS保持[^4] 放电[1:0] 放电mos断开 放电mos闭合 放电MOS自动[^3] 放电MOS保持[^4] 例如:主机需要广播BMS0:充电闭合 放电断开BMS1:充电自动 放电断开BMS3:充电断开 放电断开BMS4:充电自动 放电断开 主机: 00 10 90 04 04 08 00 08 CRC从机: 不回复 控制1号BMS主机: 01 10 90 01 04 CRC从机: 01 10 90 01 CRC 编址命令 描述 设备地址 功能码 命令码 长度 目标地址 CRC 主机发送 1byte 1byte 1byte 1byte 1 byte 2byte ^^ ADDR 0x10 0x91 0x01 ID CRC 描述 设备地址 功能码 命令码 长度 编址结果 CRC 从机回复 1byte 1byte 1byte 1byte 1byte 2byte ^^ ADDR 0x10 0x91 0x01 xx CRC 编址结果 值 缺省 0x00 本机编址完成 0x01 所有编址完成 0x02 例:主BMS编址01号BMS,后面还有电池包主机: 00 10 91 01 01 CRC从机: 01 10 91 01 01 CRC 主BMS编址05号BMS,所有编址完成主机: 00 10 91 01 05 CRC从机: 05 10 91 01 02 CRC 2.3 并包编址逻辑123456789101112131415161718192021222324sequenceDiagram autonumber %显示数字标 participant 电池包1 participant 电池包2 participant 电池包3 电池包1 --&gt;&gt; 电池包1 : 识别到自己为主机，开始执行编址 电池包1 --&gt;&gt; 电池包2 : 输出ID_OUT 电池包2 --&gt;&gt; 电池包2 : 收到输出ID_IN，监听总线地址命令 Note over 电池包1,电池包3 : 电池包1发送编电池包编址命令1 电池包2 --&gt;&gt; 电池包2 : 收到编址命令，设置地址为自己地址 电池包2 --&gt;&gt; 电池包1 : 回复编址命令1成功 Note over 电池包1,电池包3 : 电池包1发送编电池包编址命令2 电池包2 --&gt;&gt; 电池包2 : 收到编址命令为下一个包 电池包2 --&gt;&gt; 电池包3 : 输出ID_OUT 电池包3 --&gt;&gt; 电池包3 : 收到输出ID_IN，监听总线地址命令 Note over 电池包1,电池包3 : 电池包1发送编电池包编址命令2 电池包3 --&gt;&gt; 电池包3 : 收到编址命令，设置地址为自己地址 电池包3 --&gt;&gt; 电池包1 : 回复编址命令完成 电池包1 --&gt;&gt; 电池包1 : 收到编址完成命令，结束编址。 3 主任务唤醒判断逻辑12345678910flowchart TB开始--&gt;获取上次是否为主机获取上次是否为主机{{获取上次是否为主机}} --&gt; |Y| 内置电池包模式 内置电池包模式{{内置电池包模式}} --&gt; |Y| 设置为主机模式 设置为主机模式 --&gt; 运行循环任务 内置电池包模式{{内置电池包模式}} --&gt; |N| 设置为等待模式 设置为等待模式 --&gt; 运行循环任务 运行循环任务 --&gt; 结束获取上次是否为主机 --&gt; |N| 设置为等待模式 循环任务1234567891011121314151617181920212223242526272829flowchart TB当前为主机模式{{当前为主机模式?}}当前为从机模式{{当前为从机模式?}}当前为等待模式{{当前为等待模式?}}当前编址未完成{{当前编址未完成?}}编写1号从包{{编写1号从包?}}开始 --&gt; 当前为主机模式当前为主机模式 --&gt; |Y| 当前编址未完成 当前编址未完成 --&gt; |Y| 发送编址命令 主机发起编址 --&gt; 结束 当前编址未完成 --&gt; |N| 主机发起数据轮训 --&gt; 结束当前为主机模式 --&gt; |N| 当前为从机模式当前为从机模式 --&gt; |Y| 2 --&gt; 结束当前为从机模式 --&gt; |N| 当前为等待模式当前为等待模式 --&gt; |Y| 3 --&gt; 结束当前为等待模式 --&gt; |N| 结束subgraph 发送编址命令 编写1号从包 编写1号从包 --&gt; |Y| 输出ID_OUT 输出ID_OUT --&gt; 主机发起编址 编写1号从包 --&gt; |N| 主机发起编址endsubgraph 主机发起数据轮训 direction TBend 主机发起编址12345678flowchart TB开始 --&gt; 获取当前并联BMS数获取当前并联BMS数 --&gt; 当前并联BMS数为0 当前并联BMS数为0 --&gt; |Y| 设置ID_OUT为使能 设置ID_OUT为使能 --&gt; 当前并联BMS数+1发送编址命令 当前并联BMS数为0 --&gt; |N| 当前并联BMS数+1发送编址命令 当前并联BMS数+1发送编址命令 --&gt; 结束 主机发起数据轮训 需要有一个命令队列 命令队列里面没数据了才发起轮询 1234567891011typedef struct{ uint8_t contPackType;//控制模式, 01广播 02指定包 uint8_t targetBms; //控制目标Bms号 uint8_t buff[32]; //数据缓存 uint8_t SendCnt; //发送次数 uint8_t SendTimeOs; //发送时间 uint8_t ResFlg; //返回标志}发送队列;uint32_t AllResFlg; //用于描述检查多包的时候的返回情况 12345678910flowchart TB开始 --&gt; 获取命令队列subgraph 获取命令队列 direction TB end 4 通讯回调任务4.1 主板通讯回调(MB &lt;–&gt; BMS)4.2并包端口通讯回调(BMS0 &lt;–&gt; BMS1…BMSn)123456flowchart TB开始 --&gt; 主机模式主机模式{{主机模式}} --&gt; |Y|运行主机回调函数 运行主机回调函数 --&gt; 结束主机模式 --&gt; |N| 运行从机回调函数 运行从机回调函数 --&gt; 结束 4.2.1 主机回调函数12345678910flowchart TB主机模式&amp;&amp;地址在地址池内{{主机模式&amp;&amp;地址在地址池内?}}命令为编址命令{{命令为编址命令?}}开始 --&gt; 主机模式&amp;&amp;地址在地址池内主机模式&amp;&amp;地址在地址池内 --&gt; |N| 结束主机模式&amp;&amp;地址在地址池内 --&gt; |Y| 命令为编址命令 命令为编址命令 --&gt; |Y| 回调编址命令 --&gt; 结束 命令为编址命令 --&gt; |N| 回调命令回调 --&gt;结束 4.2.1.1 主机编址回调函数123456789101112flowchart TB编址成功命令{{编址成功命令?}}编址成功为末包{{编址成功为末包?}}开始 --&gt; 编址成功命令 编址成功命令 --&gt; |N| 结束编址成功命令 --&gt; |Y| 编址成功为末包 编址成功为末包 --&gt; |N| 设置并包数量+1 编址成功为末包 --&gt; |Y| 编址完成 编址完成 --&gt; 设置并包数量+1 设置并包数量+1 --&gt; 结束 4.2.1.2 主机命令回调函数从机回调函数123456789101112flowchart TB广播命令或本机命令{{广播命令或本机命令?}}命令为编址命令{{命令为编址命令?}}开始 --&gt; 广播命令或本机命令广播命令或本机命令 --&gt; |N| 结束广播命令或本机命令 --&gt; |Y| 命令为编址命令 命令为编址命令 --&gt; |Y| 编址回调函数 编址回调函数 --&gt; 结束 命令为编址命令 --&gt; |N| 命令回调函数 命令回调函数 --&gt; 结束 编址回调函数1234567891011121314151617181920212223242526flowchart TB编址完成{{编址完成?}}ID_IN被使能{{ID_IN被使能}} IN-CHK被使能{{IN-CHK被使能?}}设置地址为本机地址+1{{设置地址为本机地址+1?}}编址回调函数 --&gt; 编址完成编址完成 --&gt; |N| ID_IN被使能 ID_IN被使能 --&gt; |N| 结束 ID_IN被使能 --&gt; |Y| 设置本机地址 设置本机地址 --&gt; 结束编址完成 --&gt; |Y| 设置地址为本机地址+1 设置地址为本机地址+1 --&gt; |N| 结束 设置地址为本机地址+1 --&gt; |Y| 设置ID_OUT为使能模式 设置ID_OUT为使能模式 --&gt; 结束 subgraph 设置本机地址 direction TB 设置当前ID为本机ID --&gt; IN-CHK被使能 IN-CHK被使能 --&gt; |N| 回复末包编址完成 回复末包编址完成 --&gt; 设置本机编址完成 IN-CHK被使能 --&gt; |Y| 回复编址完成后面还有包 回复编址完成后面还有包 --&gt; 设置本机编址完成 end","link":"/p/c643e9f32c9247c89a7cb7b70fa4ec52/"},{"title":"windows系统右键打开cmd命令窗口","text":"windows系统右键打开cmd命令窗口前一阵子一直在Linux下进行编程开发和学习，最近换回在Windows下了，感觉不是那么适应了，总是希望Windows能有像Linux那样，在任意文件或文件夹下右键就能到命令终端，今天这个问题终于解决了。 解决方案为： Windows系统任意文件夹下新建文本文件，写入以下内容： 1234567Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCMD]&quot;ShowBasedOnVelocityId&quot;=dword:00639bc8[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\OpenCMD\\command]@=&quot;powershell.exe -noexit -command Set-Location -literalPath '%V'&quot; 保存，重新命名为command.reg 后缀一定要是reg的。然后直接双击执行此文件即可。 这样你就右键任意文件就有快速进入到cmd命令终端的选项了。","link":"/p/e1d27f1b05b54511bcb01429bf8dd590/"}],"tags":[{"name":"vscode 插件","slug":"vscode-插件","link":"/tags/vscode-%E6%8F%92%E4%BB%B6/"},{"name":"vs code debug","slug":"vs-code-debug","link":"/tags/vs-code-debug/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"双向dc","slug":"双向dc","link":"/tags/%E5%8F%8C%E5%90%91dc/"}],"categories":[{"name":"VSCode","slug":"VSCode","link":"/categories/VSCode/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"DcDc","slug":"DcDc","link":"/categories/DcDc/"},{"name":"BMS","slug":"BMS","link":"/categories/BMS/"},{"name":"杂项知识","slug":"杂项知识","link":"/categories/%E6%9D%82%E9%A1%B9%E7%9F%A5%E8%AF%86/"}],"pages":[]}